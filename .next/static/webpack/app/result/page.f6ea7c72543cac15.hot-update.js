"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/result/page",{

/***/ "(app-pages-browser)/./lib/imageFilters.ts":
/*!*****************************!*\
  !*** ./lib/imageFilters.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   simulateAfter: function() { return /* binding */ simulateAfter; }\n/* harmony export */ });\nfunction simulateAfter(source, productKey, skinProblems) {\n    const canvas = document.createElement(\"canvas\");\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) throw new Error(\"Canvas context non disponible\");\n    canvas.width = source.width;\n    canvas.height = source.height;\n    ctx.drawImage(source, 0, 0);\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const data = imageData.data;\n    // Si on a des problèmes détectés, appliquer un filtre intelligent ciblé\n    if (skinProblems && skinProblems.length > 0) {\n        applyTargetedFilters(data, canvas.width, canvas.height, skinProblems, productKey);\n    } else {\n        // Sinon, appliquer le filtre global de base\n        applyBasicFilter(data, productKey);\n    }\n    ctx.putImageData(imageData, 0, 0);\n    // Appliquer un léger flou pour lisser\n    const tempCanvas = document.createElement(\"canvas\");\n    const tempCtx = tempCanvas.getContext(\"2d\");\n    if (!tempCtx) return canvas;\n    tempCanvas.width = canvas.width;\n    tempCanvas.height = canvas.height;\n    tempCtx.filter = \"blur(0.8px)\";\n    tempCtx.drawImage(canvas, 0, 0);\n    // Ajouter le watermark\n    tempCtx.filter = \"none\";\n    tempCtx.font = \"16px Inter, sans-serif\";\n    tempCtx.fillStyle = \"rgba(255, 255, 255, 0.7)\";\n    tempCtx.strokeStyle = \"rgba(0, 0, 0, 0.5)\";\n    tempCtx.lineWidth = 2;\n    const text = \"AI Enhanced\";\n    const textWidth = tempCtx.measureText(text).width;\n    const x = tempCanvas.width - textWidth - 15;\n    const y = tempCanvas.height - 15;\n    tempCtx.strokeText(text, x, y);\n    tempCtx.fillText(text, x, y);\n    return tempCanvas;\n}\n/**\n * Applique des filtres ciblés sur les zones détectées\n */ function applyTargetedFilters(data, width, height, problems, productKey) {\n    // Créer une carte d'intensité de traitement pour chaque pixel\n    const treatmentMap = new Float32Array(width * height);\n    treatmentMap.fill(0);\n    // Pour chaque problème détecté, augmenter l'intensité du traitement dans cette zone\n    problems.forEach((problem)=>{\n        const x = Math.floor(problem.location.x / 100 * width);\n        const y = Math.floor(problem.location.y / 100 * height);\n        const w = Math.floor(problem.location.width / 100 * width);\n        const h = Math.floor(problem.location.height / 100 * height);\n        const intensity = problem.severity / 100;\n        const filterType = getFilterTypeForProblem(problem.type, productKey);\n        // Remplir la zone avec un gradient pour un effet naturel\n        for(let py = Math.max(0, y); py < Math.min(height, y + h); py++){\n            for(let px = Math.max(0, x); px < Math.min(width, x + w); px++){\n                const idx = py * width + px;\n                // Distance du centre de la zone (pour effet de gradient)\n                const centerX = x + w / 2;\n                const centerY = y + h / 2;\n                const distX = (px - centerX) / (w / 2);\n                const distY = (py - centerY) / (h / 2);\n                const dist = Math.sqrt(distX * distX + distY * distY);\n                const gradient = Math.max(0, 1 - dist);\n                treatmentMap[idx] = Math.max(treatmentMap[idx], intensity * gradient * filterType.strength);\n            }\n        }\n    });\n    // Appliquer les traitements pixel par pixel selon la carte d'intensité\n    for(let y = 0; y < height; y++){\n        for(let x = 0; x < width; x++){\n            const idx = y * width + x;\n            const dataIdx = idx * 4;\n            const intensity = treatmentMap[idx];\n            if (intensity > 0.05) {\n                // Appliquer le traitement avec l'intensité calculée\n                applyPixelTreatment(data, dataIdx, intensity, productKey);\n            }\n        }\n    }\n}\n/**\n * Applique un traitement sur un pixel spécifique\n */ function applyPixelTreatment(data, idx, intensity, productKey) {\n    const r = data[idx];\n    const g = data[idx + 1];\n    const b = data[idx + 2];\n    if (productKey === \"duo-eclat\") {\n        // Éclaircir et uniformiser\n        const brightness = 1 + 0.12 * intensity;\n        const rednessReduction = 0.85 + 0.15 * (1 - intensity);\n        data[idx] = Math.min(255, r * rednessReduction * brightness);\n        data[idx + 1] = Math.min(255, g * brightness);\n        data[idx + 2] = Math.min(255, b * brightness);\n        // Uniformisation\n        const avg = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;\n        const uniformFactor = 0.1 * intensity;\n        data[idx] = data[idx] * (1 - uniformFactor) + avg * uniformFactor;\n        data[idx + 1] = data[idx + 1] * (1 - uniformFactor) + avg * uniformFactor;\n        data[idx + 2] = data[idx + 2] * (1 - uniformFactor) + avg * uniformFactor;\n    } else {\n        // Apaiser et hydrater\n        const brightness = 1 + 0.08 * intensity;\n        const rednessReduction = 0.88 + 0.12 * (1 - intensity);\n        data[idx] = Math.min(255, r * rednessReduction * brightness);\n        data[idx + 1] = Math.min(255, g * brightness);\n        data[idx + 2] = Math.min(255, b * brightness);\n        // Uniformisation plus douce\n        const avg = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;\n        const uniformFactor = 0.15 * intensity;\n        data[idx] = data[idx] * (1 - uniformFactor) + avg * uniformFactor;\n        data[idx + 1] = data[idx + 1] * (1 - uniformFactor) + avg * uniformFactor;\n        data[idx + 2] = data[idx + 2] * (1 - uniformFactor) + avg * uniformFactor;\n    }\n}\n/**\n * Retourne le type de filtre à appliquer selon le type de problème\n */ function getFilterTypeForProblem(problemType, productKey) {\n    const filters = {\n        acne: {\n            strength: productKey === \"duo-eclat\" ? 1.2 : 1.0\n        },\n        wrinkle: {\n            strength: 0.8\n        },\n        dark_circle: {\n            strength: 1.0\n        },\n        pore: {\n            strength: productKey === \"duo-eclat\" ? 1.1 : 0.9\n        },\n        dark_spot: {\n            strength: productKey === \"duo-eclat\" ? 1.3 : 1.0\n        },\n        redness: {\n            strength: productKey === \"repairing-serum\" ? 1.2 : 1.0\n        }\n    };\n    return filters[problemType];\n}\n/**\n * Applique le filtre de base (ancien système)\n */ function applyBasicFilter(data, productKey) {\n    if (productKey === \"duo-eclat\") {\n        for(let i = 0; i < data.length; i += 4){\n            const r = data[i];\n            const g = data[i + 1];\n            const b = data[i + 2];\n            data[i] = r * 0.88;\n            const brightnessFactor = 1.08;\n            data[i] = Math.min(255, data[i] * brightnessFactor);\n            data[i + 1] = Math.min(255, g * brightnessFactor);\n            data[i + 2] = Math.min(255, b * brightnessFactor);\n            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;\n            data[i] = data[i] * 0.95 + avg * 0.05;\n            data[i + 1] = data[i + 1] * 0.95 + avg * 0.05;\n            data[i + 2] = data[i + 2] * 0.95 + avg * 0.05;\n        }\n    } else {\n        for(let i = 0; i < data.length; i += 4){\n            const r = data[i];\n            const g = data[i + 1];\n            const b = data[i + 2];\n            data[i] = r * 0.82;\n            const brightnessFactor = 1.04;\n            data[i] = Math.min(255, data[i] * brightnessFactor);\n            data[i + 1] = Math.min(255, g * brightnessFactor);\n            data[i + 2] = Math.min(255, b * brightnessFactor);\n            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;\n            data[i] = data[i] * 0.9 + avg * 0.1;\n            data[i + 1] = data[i + 1] * 0.9 + avg * 0.1;\n            data[i + 2] = data[i + 2] * 0.9 + avg * 0.1;\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9pbWFnZUZpbHRlcnMudHM/ZDg1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTa2luUHJvYmxlbSwgU2tpblByb2JsZW1UeXBlIH0gZnJvbSBcIi4vc2tpbkFuYWx5c2lzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaW11bGF0ZUFmdGVyKFxuICBzb3VyY2U6IEhUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCxcbiAgcHJvZHVjdEtleTogXCJkdW8tZWNsYXRcIiB8IFwicmVwYWlyaW5nLXNlcnVtXCIsXG4gIHNraW5Qcm9ibGVtcz86IFNraW5Qcm9ibGVtW11cbik6IEhUTUxDYW52YXNFbGVtZW50IHtcbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgaWYgKCFjdHgpIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBjb250ZXh0IG5vbiBkaXNwb25pYmxlXCIpO1xuXG4gIGNhbnZhcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcbiAgY2FudmFzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XG5cbiAgY3R4LmRyYXdJbWFnZShzb3VyY2UsIDAsIDApO1xuXG4gIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXG4gIC8vIFNpIG9uIGEgZGVzIHByb2Jsw6htZXMgZMOpdGVjdMOpcywgYXBwbGlxdWVyIHVuIGZpbHRyZSBpbnRlbGxpZ2VudCBjaWJsw6lcbiAgaWYgKHNraW5Qcm9ibGVtcyAmJiBza2luUHJvYmxlbXMubGVuZ3RoID4gMCkge1xuICAgIGFwcGx5VGFyZ2V0ZWRGaWx0ZXJzKGRhdGEsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgc2tpblByb2JsZW1zLCBwcm9kdWN0S2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTaW5vbiwgYXBwbGlxdWVyIGxlIGZpbHRyZSBnbG9iYWwgZGUgYmFzZVxuICAgIGFwcGx5QmFzaWNGaWx0ZXIoZGF0YSwgcHJvZHVjdEtleSk7XG4gIH1cblxuICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG5cbiAgLy8gQXBwbGlxdWVyIHVuIGzDqWdlciBmbG91IHBvdXIgbGlzc2VyXG4gIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICBjb25zdCB0ZW1wQ3R4ID0gdGVtcENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGlmICghdGVtcEN0eCkgcmV0dXJuIGNhbnZhcztcblxuICB0ZW1wQ2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuICB0ZW1wQ2FudmFzLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gIHRlbXBDdHguZmlsdGVyID0gXCJibHVyKDAuOHB4KVwiO1xuICB0ZW1wQ3R4LmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xuXG4gIC8vIEFqb3V0ZXIgbGUgd2F0ZXJtYXJrXG4gIHRlbXBDdHguZmlsdGVyID0gXCJub25lXCI7XG4gIHRlbXBDdHguZm9udCA9IFwiMTZweCBJbnRlciwgc2Fucy1zZXJpZlwiO1xuICB0ZW1wQ3R4LmZpbGxTdHlsZSA9IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpXCI7XG4gIHRlbXBDdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwgMCwgMCwgMC41KVwiO1xuICB0ZW1wQ3R4LmxpbmVXaWR0aCA9IDI7XG4gIGNvbnN0IHRleHQgPSBcIkFJIEVuaGFuY2VkXCI7XG4gIGNvbnN0IHRleHRXaWR0aCA9IHRlbXBDdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gIGNvbnN0IHggPSB0ZW1wQ2FudmFzLndpZHRoIC0gdGV4dFdpZHRoIC0gMTU7XG4gIGNvbnN0IHkgPSB0ZW1wQ2FudmFzLmhlaWdodCAtIDE1O1xuICB0ZW1wQ3R4LnN0cm9rZVRleHQodGV4dCwgeCwgeSk7XG4gIHRlbXBDdHguZmlsbFRleHQodGV4dCwgeCwgeSk7XG5cbiAgcmV0dXJuIHRlbXBDYW52YXM7XG59XG5cbi8qKlxuICogQXBwbGlxdWUgZGVzIGZpbHRyZXMgY2libMOpcyBzdXIgbGVzIHpvbmVzIGTDqXRlY3TDqWVzXG4gKi9cbmZ1bmN0aW9uIGFwcGx5VGFyZ2V0ZWRGaWx0ZXJzKFxuICBkYXRhOiBVaW50OENsYW1wZWRBcnJheSxcbiAgd2lkdGg6IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIHByb2JsZW1zOiBTa2luUHJvYmxlbVtdLFxuICBwcm9kdWN0S2V5OiBcImR1by1lY2xhdFwiIHwgXCJyZXBhaXJpbmctc2VydW1cIlxuKSB7XG4gIC8vIENyw6llciB1bmUgY2FydGUgZCdpbnRlbnNpdMOpIGRlIHRyYWl0ZW1lbnQgcG91ciBjaGFxdWUgcGl4ZWxcbiAgY29uc3QgdHJlYXRtZW50TWFwID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCk7XG4gIHRyZWF0bWVudE1hcC5maWxsKDApO1xuXG4gIC8vIFBvdXIgY2hhcXVlIHByb2Jsw6htZSBkw6l0ZWN0w6ksIGF1Z21lbnRlciBsJ2ludGVuc2l0w6kgZHUgdHJhaXRlbWVudCBkYW5zIGNldHRlIHpvbmVcbiAgcHJvYmxlbXMuZm9yRWFjaChwcm9ibGVtID0+IHtcbiAgICBjb25zdCB4ID0gTWF0aC5mbG9vcigocHJvYmxlbS5sb2NhdGlvbi54IC8gMTAwKSAqIHdpZHRoKTtcbiAgICBjb25zdCB5ID0gTWF0aC5mbG9vcigocHJvYmxlbS5sb2NhdGlvbi55IC8gMTAwKSAqIGhlaWdodCk7XG4gICAgY29uc3QgdyA9IE1hdGguZmxvb3IoKHByb2JsZW0ubG9jYXRpb24ud2lkdGggLyAxMDApICogd2lkdGgpO1xuICAgIGNvbnN0IGggPSBNYXRoLmZsb29yKChwcm9ibGVtLmxvY2F0aW9uLmhlaWdodCAvIDEwMCkgKiBoZWlnaHQpO1xuXG4gICAgY29uc3QgaW50ZW5zaXR5ID0gcHJvYmxlbS5zZXZlcml0eSAvIDEwMDtcbiAgICBjb25zdCBmaWx0ZXJUeXBlID0gZ2V0RmlsdGVyVHlwZUZvclByb2JsZW0ocHJvYmxlbS50eXBlLCBwcm9kdWN0S2V5KTtcblxuICAgIC8vIFJlbXBsaXIgbGEgem9uZSBhdmVjIHVuIGdyYWRpZW50IHBvdXIgdW4gZWZmZXQgbmF0dXJlbFxuICAgIGZvciAobGV0IHB5ID0gTWF0aC5tYXgoMCwgeSk7IHB5IDwgTWF0aC5taW4oaGVpZ2h0LCB5ICsgaCk7IHB5KyspIHtcbiAgICAgIGZvciAobGV0IHB4ID0gTWF0aC5tYXgoMCwgeCk7IHB4IDwgTWF0aC5taW4od2lkdGgsIHggKyB3KTsgcHgrKykge1xuICAgICAgICBjb25zdCBpZHggPSBweSAqIHdpZHRoICsgcHg7XG5cbiAgICAgICAgLy8gRGlzdGFuY2UgZHUgY2VudHJlIGRlIGxhIHpvbmUgKHBvdXIgZWZmZXQgZGUgZ3JhZGllbnQpXG4gICAgICAgIGNvbnN0IGNlbnRlclggPSB4ICsgdyAvIDI7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSB5ICsgaCAvIDI7XG4gICAgICAgIGNvbnN0IGRpc3RYID0gKHB4IC0gY2VudGVyWCkgLyAodyAvIDIpO1xuICAgICAgICBjb25zdCBkaXN0WSA9IChweSAtIGNlbnRlclkpIC8gKGggLyAyKTtcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguc3FydChkaXN0WCAqIGRpc3RYICsgZGlzdFkgKiBkaXN0WSk7XG4gICAgICAgIGNvbnN0IGdyYWRpZW50ID0gTWF0aC5tYXgoMCwgMSAtIGRpc3QpO1xuXG4gICAgICAgIHRyZWF0bWVudE1hcFtpZHhdID0gTWF0aC5tYXgodHJlYXRtZW50TWFwW2lkeF0sIGludGVuc2l0eSAqIGdyYWRpZW50ICogZmlsdGVyVHlwZS5zdHJlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBBcHBsaXF1ZXIgbGVzIHRyYWl0ZW1lbnRzIHBpeGVsIHBhciBwaXhlbCBzZWxvbiBsYSBjYXJ0ZSBkJ2ludGVuc2l0w6lcbiAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgY29uc3QgaWR4ID0geSAqIHdpZHRoICsgeDtcbiAgICAgIGNvbnN0IGRhdGFJZHggPSBpZHggKiA0O1xuICAgICAgY29uc3QgaW50ZW5zaXR5ID0gdHJlYXRtZW50TWFwW2lkeF07XG5cbiAgICAgIGlmIChpbnRlbnNpdHkgPiAwLjA1KSB7XG4gICAgICAgIC8vIEFwcGxpcXVlciBsZSB0cmFpdGVtZW50IGF2ZWMgbCdpbnRlbnNpdMOpIGNhbGN1bMOpZVxuICAgICAgICBhcHBseVBpeGVsVHJlYXRtZW50KGRhdGEsIGRhdGFJZHgsIGludGVuc2l0eSwgcHJvZHVjdEtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXBwbGlxdWUgdW4gdHJhaXRlbWVudCBzdXIgdW4gcGl4ZWwgc3DDqWNpZmlxdWVcbiAqL1xuZnVuY3Rpb24gYXBwbHlQaXhlbFRyZWF0bWVudChcbiAgZGF0YTogVWludDhDbGFtcGVkQXJyYXksXG4gIGlkeDogbnVtYmVyLFxuICBpbnRlbnNpdHk6IG51bWJlcixcbiAgcHJvZHVjdEtleTogXCJkdW8tZWNsYXRcIiB8IFwicmVwYWlyaW5nLXNlcnVtXCJcbikge1xuICBjb25zdCByID0gZGF0YVtpZHhdO1xuICBjb25zdCBnID0gZGF0YVtpZHggKyAxXTtcbiAgY29uc3QgYiA9IGRhdGFbaWR4ICsgMl07XG5cbiAgaWYgKHByb2R1Y3RLZXkgPT09IFwiZHVvLWVjbGF0XCIpIHtcbiAgICAvLyDDiWNsYWlyY2lyIGV0IHVuaWZvcm1pc2VyXG4gICAgY29uc3QgYnJpZ2h0bmVzcyA9IDEgKyAoMC4xMiAqIGludGVuc2l0eSk7XG4gICAgY29uc3QgcmVkbmVzc1JlZHVjdGlvbiA9IDAuODUgKyAoMC4xNSAqICgxIC0gaW50ZW5zaXR5KSk7XG5cbiAgICBkYXRhW2lkeF0gPSBNYXRoLm1pbigyNTUsIHIgKiByZWRuZXNzUmVkdWN0aW9uICogYnJpZ2h0bmVzcyk7XG4gICAgZGF0YVtpZHggKyAxXSA9IE1hdGgubWluKDI1NSwgZyAqIGJyaWdodG5lc3MpO1xuICAgIGRhdGFbaWR4ICsgMl0gPSBNYXRoLm1pbigyNTUsIGIgKiBicmlnaHRuZXNzKTtcblxuICAgIC8vIFVuaWZvcm1pc2F0aW9uXG4gICAgY29uc3QgYXZnID0gKGRhdGFbaWR4XSArIGRhdGFbaWR4ICsgMV0gKyBkYXRhW2lkeCArIDJdKSAvIDM7XG4gICAgY29uc3QgdW5pZm9ybUZhY3RvciA9IDAuMSAqIGludGVuc2l0eTtcbiAgICBkYXRhW2lkeF0gPSBkYXRhW2lkeF0gKiAoMSAtIHVuaWZvcm1GYWN0b3IpICsgYXZnICogdW5pZm9ybUZhY3RvcjtcbiAgICBkYXRhW2lkeCArIDFdID0gZGF0YVtpZHggKyAxXSAqICgxIC0gdW5pZm9ybUZhY3RvcikgKyBhdmcgKiB1bmlmb3JtRmFjdG9yO1xuICAgIGRhdGFbaWR4ICsgMl0gPSBkYXRhW2lkeCArIDJdICogKDEgLSB1bmlmb3JtRmFjdG9yKSArIGF2ZyAqIHVuaWZvcm1GYWN0b3I7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXBhaXNlciBldCBoeWRyYXRlclxuICAgIGNvbnN0IGJyaWdodG5lc3MgPSAxICsgKDAuMDggKiBpbnRlbnNpdHkpO1xuICAgIGNvbnN0IHJlZG5lc3NSZWR1Y3Rpb24gPSAwLjg4ICsgKDAuMTIgKiAoMSAtIGludGVuc2l0eSkpO1xuXG4gICAgZGF0YVtpZHhdID0gTWF0aC5taW4oMjU1LCByICogcmVkbmVzc1JlZHVjdGlvbiAqIGJyaWdodG5lc3MpO1xuICAgIGRhdGFbaWR4ICsgMV0gPSBNYXRoLm1pbigyNTUsIGcgKiBicmlnaHRuZXNzKTtcbiAgICBkYXRhW2lkeCArIDJdID0gTWF0aC5taW4oMjU1LCBiICogYnJpZ2h0bmVzcyk7XG5cbiAgICAvLyBVbmlmb3JtaXNhdGlvbiBwbHVzIGRvdWNlXG4gICAgY29uc3QgYXZnID0gKGRhdGFbaWR4XSArIGRhdGFbaWR4ICsgMV0gKyBkYXRhW2lkeCArIDJdKSAvIDM7XG4gICAgY29uc3QgdW5pZm9ybUZhY3RvciA9IDAuMTUgKiBpbnRlbnNpdHk7XG4gICAgZGF0YVtpZHhdID0gZGF0YVtpZHhdICogKDEgLSB1bmlmb3JtRmFjdG9yKSArIGF2ZyAqIHVuaWZvcm1GYWN0b3I7XG4gICAgZGF0YVtpZHggKyAxXSA9IGRhdGFbaWR4ICsgMV0gKiAoMSAtIHVuaWZvcm1GYWN0b3IpICsgYXZnICogdW5pZm9ybUZhY3RvcjtcbiAgICBkYXRhW2lkeCArIDJdID0gZGF0YVtpZHggKyAyXSAqICgxIC0gdW5pZm9ybUZhY3RvcikgKyBhdmcgKiB1bmlmb3JtRmFjdG9yO1xuICB9XG59XG5cbi8qKlxuICogUmV0b3VybmUgbGUgdHlwZSBkZSBmaWx0cmUgw6AgYXBwbGlxdWVyIHNlbG9uIGxlIHR5cGUgZGUgcHJvYmzDqG1lXG4gKi9cbmZ1bmN0aW9uIGdldEZpbHRlclR5cGVGb3JQcm9ibGVtKFxuICBwcm9ibGVtVHlwZTogU2tpblByb2JsZW1UeXBlLFxuICBwcm9kdWN0S2V5OiBcImR1by1lY2xhdFwiIHwgXCJyZXBhaXJpbmctc2VydW1cIlxuKTogeyBzdHJlbmd0aDogbnVtYmVyIH0ge1xuICBjb25zdCBmaWx0ZXJzID0ge1xuICAgIGFjbmU6IHsgc3RyZW5ndGg6IHByb2R1Y3RLZXkgPT09IFwiZHVvLWVjbGF0XCIgPyAxLjIgOiAxLjAgfSxcbiAgICB3cmlua2xlOiB7IHN0cmVuZ3RoOiAwLjggfSxcbiAgICBkYXJrX2NpcmNsZTogeyBzdHJlbmd0aDogMS4wIH0sXG4gICAgcG9yZTogeyBzdHJlbmd0aDogcHJvZHVjdEtleSA9PT0gXCJkdW8tZWNsYXRcIiA/IDEuMSA6IDAuOSB9LFxuICAgIGRhcmtfc3BvdDogeyBzdHJlbmd0aDogcHJvZHVjdEtleSA9PT0gXCJkdW8tZWNsYXRcIiA/IDEuMyA6IDEuMCB9LFxuICAgIHJlZG5lc3M6IHsgc3RyZW5ndGg6IHByb2R1Y3RLZXkgPT09IFwicmVwYWlyaW5nLXNlcnVtXCIgPyAxLjIgOiAxLjAgfSxcbiAgfTtcblxuICByZXR1cm4gZmlsdGVyc1twcm9ibGVtVHlwZV07XG59XG5cbi8qKlxuICogQXBwbGlxdWUgbGUgZmlsdHJlIGRlIGJhc2UgKGFuY2llbiBzeXN0w6htZSlcbiAqL1xuZnVuY3Rpb24gYXBwbHlCYXNpY0ZpbHRlcihkYXRhOiBVaW50OENsYW1wZWRBcnJheSwgcHJvZHVjdEtleTogXCJkdW8tZWNsYXRcIiB8IFwicmVwYWlyaW5nLXNlcnVtXCIpIHtcbiAgaWYgKHByb2R1Y3RLZXkgPT09IFwiZHVvLWVjbGF0XCIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGNvbnN0IHIgPSBkYXRhW2ldO1xuICAgICAgY29uc3QgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgY29uc3QgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgICBkYXRhW2ldID0gciAqIDAuODg7XG5cbiAgICAgIGNvbnN0IGJyaWdodG5lc3NGYWN0b3IgPSAxLjA4O1xuICAgICAgZGF0YVtpXSA9IE1hdGgubWluKDI1NSwgZGF0YVtpXSAqIGJyaWdodG5lc3NGYWN0b3IpO1xuICAgICAgZGF0YVtpICsgMV0gPSBNYXRoLm1pbigyNTUsIGcgKiBicmlnaHRuZXNzRmFjdG9yKTtcbiAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5taW4oMjU1LCBiICogYnJpZ2h0bmVzc0ZhY3Rvcik7XG5cbiAgICAgIGNvbnN0IGF2ZyA9IChkYXRhW2ldICsgZGF0YVtpICsgMV0gKyBkYXRhW2kgKyAyXSkgLyAzO1xuICAgICAgZGF0YVtpXSA9IGRhdGFbaV0gKiAwLjk1ICsgYXZnICogMC4wNTtcbiAgICAgIGRhdGFbaSArIDFdID0gZGF0YVtpICsgMV0gKiAwLjk1ICsgYXZnICogMC4wNTtcbiAgICAgIGRhdGFbaSArIDJdID0gZGF0YVtpICsgMl0gKiAwLjk1ICsgYXZnICogMC4wNTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBjb25zdCByID0gZGF0YVtpXTtcbiAgICAgIGNvbnN0IGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgIGNvbnN0IGIgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgZGF0YVtpXSA9IHIgKiAwLjgyO1xuXG4gICAgICBjb25zdCBicmlnaHRuZXNzRmFjdG9yID0gMS4wNDtcbiAgICAgIGRhdGFbaV0gPSBNYXRoLm1pbigyNTUsIGRhdGFbaV0gKiBicmlnaHRuZXNzRmFjdG9yKTtcbiAgICAgIGRhdGFbaSArIDFdID0gTWF0aC5taW4oMjU1LCBnICogYnJpZ2h0bmVzc0ZhY3Rvcik7XG4gICAgICBkYXRhW2kgKyAyXSA9IE1hdGgubWluKDI1NSwgYiAqIGJyaWdodG5lc3NGYWN0b3IpO1xuXG4gICAgICBjb25zdCBhdmcgPSAoZGF0YVtpXSArIGRhdGFbaSArIDFdICsgZGF0YVtpICsgMl0pIC8gMztcbiAgICAgIGRhdGFbaV0gPSBkYXRhW2ldICogMC45ICsgYXZnICogMC4xO1xuICAgICAgZGF0YVtpICsgMV0gPSBkYXRhW2kgKyAxXSAqIDAuOSArIGF2ZyAqIDAuMTtcbiAgICAgIGRhdGFbaSArIDJdID0gZGF0YVtpICsgMl0gKiAwLjkgKyBhdmcgKiAwLjE7XG4gICAgfVxuICB9XG59Il0sIm5hbWVzIjpbInNpbXVsYXRlQWZ0ZXIiLCJzb3VyY2UiLCJwcm9kdWN0S2V5Iiwic2tpblByb2JsZW1zIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsIkVycm9yIiwid2lkdGgiLCJoZWlnaHQiLCJkcmF3SW1hZ2UiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJkYXRhIiwibGVuZ3RoIiwiYXBwbHlUYXJnZXRlZEZpbHRlcnMiLCJhcHBseUJhc2ljRmlsdGVyIiwicHV0SW1hZ2VEYXRhIiwidGVtcENhbnZhcyIsInRlbXBDdHgiLCJmaWx0ZXIiLCJmb250IiwiZmlsbFN0eWxlIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJ0ZXh0IiwidGV4dFdpZHRoIiwibWVhc3VyZVRleHQiLCJ4IiwieSIsInN0cm9rZVRleHQiLCJmaWxsVGV4dCIsInByb2JsZW1zIiwidHJlYXRtZW50TWFwIiwiRmxvYXQzMkFycmF5IiwiZmlsbCIsImZvckVhY2giLCJwcm9ibGVtIiwiTWF0aCIsImZsb29yIiwibG9jYXRpb24iLCJ3IiwiaCIsImludGVuc2l0eSIsInNldmVyaXR5IiwiZmlsdGVyVHlwZSIsImdldEZpbHRlclR5cGVGb3JQcm9ibGVtIiwidHlwZSIsInB5IiwibWF4IiwibWluIiwicHgiLCJpZHgiLCJjZW50ZXJYIiwiY2VudGVyWSIsImRpc3RYIiwiZGlzdFkiLCJkaXN0Iiwic3FydCIsImdyYWRpZW50Iiwic3RyZW5ndGgiLCJkYXRhSWR4IiwiYXBwbHlQaXhlbFRyZWF0bWVudCIsInIiLCJnIiwiYiIsImJyaWdodG5lc3MiLCJyZWRuZXNzUmVkdWN0aW9uIiwiYXZnIiwidW5pZm9ybUZhY3RvciIsInByb2JsZW1UeXBlIiwiZmlsdGVycyIsImFjbmUiLCJ3cmlua2xlIiwiZGFya19jaXJjbGUiLCJwb3JlIiwiZGFya19zcG90IiwicmVkbmVzcyIsImkiLCJicmlnaHRuZXNzRmFjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/imageFilters.ts\n"));

/***/ })

});